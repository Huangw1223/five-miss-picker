<!DOCTYPE html>
<html lang="zh-TW">
<head>
  <meta charset="UTF-8">
  <title>äº”é¸ä¸ä¸­çµ„åˆæ¨è–¦å™¨</title>
  <style>
    body { font-family: sans-serif; padding: 20px; background: #f0f0f0; }
    h2 { color: #333; }
    input, button { font-size: 16px; padding: 6px; margin: 5px 0; }
    #output, #history { background: #fff; padding: 10px; border-radius: 8px; margin-top: 20px; }
    .error { color: red; font-weight: bold; }
  </style>
</head>
<body>
  <h2>ğŸ¯ äº”é¸ä¸ä¸­æ¨è–¦å™¨ï¼ˆè‡ªå‹•æ¯”å°èˆ‡è¨˜åˆ†ï¼‰</h2>
  <p>è«‹ä¾åºè¼¸å…¥æ¯æœŸé–‹çè™Ÿç¢¼ï¼ˆç”¨ç©ºç™½åˆ†éš”ï¼Œäº”ç¢¼ï¼‰ï¼š</p>
  <input type="text" id="drawInput" placeholder="ä¾‹å¦‚ï¼š5 12 28 31 36" size="30" />
  <button onclick="addDrawAndCheck()">â• è¼¸å…¥ä¸¦æ¯”å°</button>
  <button onclick="removeLastDraw()">âŒ é‡æ–°è¼¸å…¥ä¸Šä¸€æœŸ</button>

  <div id="output">å°šæœªè¼¸å…¥ä»»ä½•é–‹ççµ„åˆã€‚</div>
  <div id="history"></div>

  <script>
    const allCombinations = generateAllCombinations();
    const drawHistory = [];
    let recommendedHistory = [];
    let score = 0;
    let maxScore = 0;
    let minScore = 0;

    function generateAllCombinations() {
      const result = [];
      for (let a = 1; a <= 35; a++)
        for (let b = a + 1; b <= 36; b++)
          for (let c = b + 1; c <= 37; c++)
            for (let d = c + 1; d <= 38; d++)
              for (let e = d + 1; e <= 39; e++)
                result.push([a, b, c, d, e]);
      return result;
    }

    function addDrawAndCheck() {
      const input = document.getElementById('drawInput').value.trim();
      const parts = input.split(/\s+/).map(n => parseInt(n.trim()));
      if (parts.length !== 5 || parts.some(n => isNaN(n))) {
        alert('è«‹è¼¸å…¥ 5 å€‹ä»¥ç©ºç™½åˆ†éš”çš„æ•¸å­—');
        return;
      }
      const nums = parts;
      if (nums.some(n => n < 1 || n > 39)) {
        alert('è™Ÿç¢¼å¿…é ˆä»‹æ–¼ 1 åˆ° 39');
        return;
      }

      const newDraw = new Set(nums);

      if (recommendedHistory.length > 0) {
        const lastRec = recommendedHistory[recommendedHistory.length - 1];
        const hit = lastRec.some(n => newDraw.has(n));
        if (hit) {
          score -= 10;
        } else {
          score += 10;
        }
        if (score > maxScore) maxScore = score;
        if (score < minScore) minScore = score;
      }

      drawHistory.push(newDraw);
      document.getElementById('drawInput').value = '';
      recommend();
      showHistory();
    }

    function removeLastDraw() {
      if (drawHistory.length > 0) {
        drawHistory.pop();
        if (recommendedHistory.length > 0) recommendedHistory.pop();
        score = 0;
        maxScore = 0;
        minScore = 0;
        for (let i = 0; i < drawHistory.length; i++) {
          const draw = drawHistory[i];
          const rec = recommendInternal(i);
          recommendedHistory[i] = rec;
          const hit = rec.some(n => draw.has(n));
          score += hit ? -10 : 10;
          if (score > maxScore) maxScore = score;
          if (score < minScore) minScore = score;
        }
        showHistory();
        recommend();
      }
    }

    function recommend() {
      if (drawHistory.length === 0) {
        updateOutput('âŒ å°šæœªè¼¸å…¥ä»»ä½•é–‹çè™Ÿç¢¼çµ„åˆã€‚');
        return;
      }

      let maxMissCount = -1;
      let bestCombo = null;

      for (const combo of allCombinations) {
        let missCount = 0;
        for (const draw of drawHistory) {
          if (!combo.some(n => draw.has(n))) {
            missCount++;
          }
        }
        if (missCount > maxMissCount) {
          maxMissCount = missCount;
          bestCombo = combo;
        }
      }

      if (bestCombo) {
        recommendedHistory.push(bestCombo);
        updateOutput(`âœ… æ¨è–¦ä¸‹æœŸçµ„åˆï¼ˆéŒ¯é ${maxMissCount} æ¬¡ï¼‰ï¼š<strong>${bestCombo.join(', ')}</strong><br/>ç›®å‰åˆ†æ•¸ï¼š${score}<br/>ğŸ”º æœ€å¤š +${maxScore} / ğŸ”» æœ€å¤š ${minScore}<br/>ğŸ“… ç›®å‰å·²è¼¸å…¥ ${drawHistory.length} æœŸé–‹çè™Ÿç¢¼`);
      } else {
        updateOutput('âŒ ç„¡å¯æ¨è–¦çš„çµ„åˆã€‚');
      }
    }

    function recommendInternal(untilIndex) {
      let maxMissCount = -1;
      let bestCombo = null;
      for (const combo of allCombinations) {
        let missCount = 0;
        for (let i = 0; i < untilIndex; i++) {
          const draw = drawHistory[i];
          if (!combo.some(n => draw.has(n))) {
            missCount++;
          }
        }
        if (missCount > maxMissCount) {
          maxMissCount = missCount;
          bestCombo = combo;
        }
      }
      return bestCombo;
    }

    function showHistory() {
      const div = document.getElementById('history');
      if (drawHistory.length === 0) {
        div.innerHTML = '';
      } else {
        const latest = Array.from(drawHistory[drawHistory.length - 1]).join(', ');
        div.innerHTML = `<h3>ğŸ“Œ æœ€æ–°è¼¸å…¥è™Ÿç¢¼ï¼ˆç¬¬ ${drawHistory.length} æœŸï¼‰ï¼š</h3><div>${latest}</div>`;
      }
    }

    function updateOutput(html) {
      document.getElementById('output').innerHTML = html;
    }
  </script>
</body>
</html>
